# 概述
Go程序的编译速度比其他语言快，即便从零开始编译也是如此。主要有3个原因。
1. 所有的导入都在每个源文件的开头显式列出，编译器在确定依赖性时不需要读取和处理整个文件。
2. 包的依赖性形成有向无环图，因为没有环，所以包可以独立甚至并行编译。
3. Go包编译出的目标文件不仅记录它自己的导出信息，还记录它所依赖包的导出信息。当编译一个包时，编译器必须从每一个导入中读取一个目标文件，
但是不会超出这些文件。
   
# 导入路径
每一个包都通过一个唯一的字符串进行标识，称为导入路径。用在import声明中。

对于准备共享或公开的包，导入路径需要全局唯一。为了避免冲突，除了标准码库中的包之外，其他包的导入路径应该以互联网域名（组织机构拥有的域名或存放包的域名）作为路径的开始，这样也方便查找包。

# 包的声明
在每一个Go源文件的开头都需要进行包声明。主要目的是当该包被其他包引入时作为其默认的标识符（包名）。

通常，包名是导入路径的最后一段。所以，即使导入路径不同的两个包，二者也可以用于同样的名字。但是有个三个例外。

1. 不管包的导入路径是什么，如果该包定义一条命令（可执行的Go程序），那么它总是使用名称main。这是告诉go build的信号，它必须调用连接器生成可执行文件。

2. 目录中可能有一些文件名字以_test.go结尾，包名中会以_test结尾。这样一个目录中有两个包：一个普通包，加上一个外部测试包。
_test后缀告诉go test两个包都需要构建，并且指明文件属于哪一个包。外部测试包用来避免测试所依赖的导入图中的循环依赖。

3. 一些管理工具会在包导入路径的尾部追加版本号后缀，如"gopkg.in/yaml.v2"。包名包含后缀，因此这个情况下包名为yaml。

# 导入声明
一个Go源文件可以在package声明的后面和第一个非导入声明语句前面紧接着包含0个或多个import声明。每一个导入可以单独指定一条导入路径，也可以通过圆括号括起来的列表一次导入多个包。

下面两种声明形式是等价的，但是第二种形式更常见。
```go
import "fmt"
import "os"

import (
	"fmt"
	"os"
)
```

导入的包可以通过空行进行分组，这类分组通常表示不同领域和方面的包。包的导入顺序不重要，但按照惯例每一组都按照字母进行排序。

每个导入声明从当前包向导入的包建立一个依赖。如果这些依赖形成一个循环，go build工具会报错。

## 重命名导入
导入相同命名的包时，需要为其中一个包指定代替名称来避免冲突。
```go
import (
	"crypto/rand"
	mrand "math/rand"
)
```

在导入的包的名称过于冗长时，使用一个替代名字可能更方便。

代替名字仅影响当前文件。其他文件（即便是同一个包中的文件）可以使用默认名字来导入包，或者一个替代名字可以。

# 空导入
如果导入的包的名字没有在文件中利用，就会产生一个编译错误。但是，有时，我们必须导入一个包，为了对包级别的变量进行初始化表达式求值，并执行它的init函数。

为了防止"未使用的导入错误"，必须使用一个重命名导入，使用一个替代的名字_，这表示导入的内容为空白标识符。通常情况下，空白标识符不能被引用。
```go
import _ "image/png" // 注册PNG解码器
```

# go工具
## GOPATH
GOPATH指定工作空间的根目录。

GOPATH有3个子目录。src子目录包含源文件；pkg子目录存储构建工具编译后的包；bin子目录放置可执行程序。

## GOROOT
GOROOT指定Go发行版的根目录，其中提供所有标准库的包。GOROOT下面的目录结构类似于GOPATH。

用户无需设置GOROOT，因为默认情况下go工具使用它的安装路径。

## GOOS
GOOS指定目标操作系统（android，linux，darwin或者windows）。

## GOARCH
GOARCH指定目标处理器架构（amd64、386或arm）

## 包的下载
如果使用go工具，包的导入路径不仅指示了如何在本地工作空间中找打它的位置，还可以通过互联网使用go get来获取和更新。

go get命令可以下载单一的包，也可以使用...符号来下载子树或仓库，该工具也计算并下载初始包所有的依赖。在go get完成包的下载后，它会构建它们，然后安装库和相应的命令。

go get -u命令通常获取每个包的最新版本。

## 包的构建
go build命令编译每一个命令行参数中的包。如果包是一个库，结果会被舍弃；对于没有编译错误的包几乎不做检查。如果包的名字是main，go build调用链接器在当前目录中创建可执行程序，可执行程序的名字取自包的导入路径的最后一段。

每一个目录包含一个包，每一个可执行程序或者UNIX命令都需要自己的目录。

包可以通过指定目录来指定，可以使用导入路径或者一个相对目录名，目录必须以.或者..开头。如果没有提供参数，会使用当前目录作为参数。

包也可以使用一个文件列表来指定，如果包名是main，可执行程序的名字来自第一个.go文件名的主体部分。

printargs.go
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Printf("%q \n", os.Args[1:])
}
```

```shell
go build printargs.go
./printargs one two three four five
["one", "two", "three", "four", "five"]
```
对于这类即用即抛类型的程序，需要在构建之后尽快运行，go run命令将这两步合并起来。
```shell
go run printargs.go one two three four five
["one", "two", "three", "four", "five"]
```
第一个不是以.go文件结尾的参数会作为Go可执行程序的参数列表的开始。

go install命令和go build非常相似，区别是它会保存每一个包的编译代码和命令，而不是把它们丢弃。编译后的包保存在$GOPATH/pkg目录中，它对应于存放源文件的src目录，可执行的命令保存在$GOPATH/bin目录中。这样go build和go install对于没有改变的包和命令不需要重新编译，从而使后续的构建更加快速。惯例上，go build -i 可以将包安装在独立于构建目标的地方。

因为编译包根据操作系统平台和CPU体系结构不同而不同，所以go install将保存它们的目录命名为与GOOS和GOARCH变量的值相关。
示例。
```go
func main() {
    fmt.Println(runtime.GOOS, runtime.GOARCH)
}
```
下面的命令分别生成64位和32位的可执行程序：
```shell
go build main.go
./main
darwin amd64
GOARCH=386 go build main.go
./main
darwin 386
```

为了处理底层的可移植性问题或为重要的例程提供优化版本，有一些包需要为特定的平台或处理器编译不同版本的代码。如果一个文件名包含操作系统或处理器体系结构名字（net_linux.go或asm_amd64.s），go工具只会在构建指定规格的目标文件的时候才进行编译。叫作构建标签的特殊注释，提供更细粒度的控制。

例如，如果一个文件包含下面的注释：
```go
// +build linux darwin
```
注释在包的声明之前（文档注释），go build只会在构建Linux或Mac os系统应用的时候才会对它进行编译。下面的注释指出任何时候都不要编译这个文件。
```go
// +build ignore
```

## 包的文档化
Go文档注释总是完整的语句，使用声明的包名作为开头的第一句注释通常是总结。函数参数和其他的标识符无须括起来或者特别标注。

包声明的前面的文档注释被认为是整个包的文档注释。尽管它可以出现在任何文件中，但是必须只有一个。比较长的包注释可以使用一个单独的注释文件，文件名通常叫doc.go。

go doc工具初识在命令行上指定的内容的声明和整个文档注释。

## 包的查询
go list工具上报可用包的信息。通过最简单的形式，go list判断一个包是否存在于工作空间中，如果存在输出它的导入半径。
```shell
go list github.com/go-sql-driver/mysql
github.com/go-sql-driver/mysql
```

go list -json使go list以Json格式输出每一个包的完整记录。

go list -f可以让用户通过text/template包提供的模板语言来定制输出格式。