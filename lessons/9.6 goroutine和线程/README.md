
# goroutine和线程
goroutine和线程的区别

# 栈内存
每个OS线程都有一个固定大小的栈内存（通常为2MB）。栈内存区域用于保存其他函数调用期间那些正在执行或者临时暂停的函数中的局部变量。

对于一个小的goroutine，2MB的栈无疑是个巨大的浪费。同时在Go程序中一次性创建十万左右的goroutine并不罕见，这时栈内存的开销是相当巨大的。

对于最复杂和深度递归的函数，固定大小的栈始终不够大。

一个goroutine在生命周期开始只有一个很小的栈内存，典型情况下为2KB。
与OS线程类似，goroutine的栈也用于存放那些正在执行或临时暂停的函数中的局部变量。与OS线程不同的是，goroutine的栈不是固定大小的，
它可以按需增大或缩小。

# 调度
OS线程由OS内核调度。每隔几毫秒，一个硬件时钟中断发送到CPU，CPU调用一个叫调度器的内核函数。这个函数暂停当前正在运行的线程，
把它的寄存器信息保存到内存，查看线程列表并决定接下来运行哪一个线程，再从内存恢复线程的注册表信息，最后继续执行选中的线程。

因为OS线程由内核来调度，所以控制权从一个线程到另一个线程需要一个完整的上下文切换（context switch）：即保存一个线程的状态到内存，
再恢复另一个线程的状态，最后更新调度器的数据结构。考虑这个操作涉及的内存局域性以及涉及的内存访问数量，还有访问内存所需的CPU周期数量的增加，
这个操作会很慢。

Go运行时包含一个自己的调度器，这个调度器使用一个称为m:n调度技术（它可以复用/调度m个goroutine到n个OS线程）。Go调度器与内核调度器的工作类似，
但是Go调度器只需关心单个Go程序的goroutine调度问题。

与操作系统的线程调度器不同的是，Go调度器不是由硬件时钟来定期触发的，而是由特定的Go语言结构来触发的。

比如当一个goroutine调用time.Sleep或被通道阻塞或对互斥量操作时，调度器就会将这个goroutine设为休眠模式，
并运行其他goroutine直到前一个可重新唤醒为止。因为它不需要切换到内核语境，所以调度一个goroutine比调度一个线程成本低很多。

# GOMAXPROCS
Go调度器使用GOMAXPROCS参数来确定需要使用多个OS线程来同时执行Go代码。默认值是机器上的逻辑CPU数量，所以在一个有着8核CPU的机器上，
调度器会把Go代码同时调度到8个OS线程上。（GOMAXPROCS是m:n调度中的n）

正在休眠或者正在被通道通信阻塞的goroutine不需要占用线程。

可以使用GOMAXPROCS环境变量或者runtime.GOMAXPROCS函数来显式控制这个参数。

# 标识
在大部分支持多线程的操作系统和编程语言里，当前线程都有一个独特的标识，它通常可以取一个整数或者指针。这个特性可以让我们轻松构建一个线程的局部存储，
它本质上就是一个全局的map，以线程的标识作为键，这样每个线程都可以独立地用这个map存储和获取值，而不受其他线程干扰。

goroutine没有可供程序员访问的标识，因为线程局部存储有一种被滥用的倾向。



